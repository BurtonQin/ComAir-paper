\section{Understanding Real-World Complexity Bugs}
\label{sec:study}


In this section, we conduct an empirical study on real-world complexity bugs. 
Specifically, we try to answer the following two questions:

\begin{enumerate}

\item What are common root causes for complexity bugs? 
Here, we consider code constructs conducting computation in unexpected complexity as root causes. 
Studying root causes can help us understand whether or not 
existing algorithmic profiling algorithms work on real-world bugs 
and can also guide the design of new approximate algorithms. 

\item How real-world complexity bugs are reported, diagnosed, and fixed?
This can help us understand the state of practice of combating process for complexity bugs. 

\end{enumerate}


\subsection{Methodology}
\label{sec:meth}

We conduct our empirical study based on a public benchmark set for 
real-world performance bugs~\cite{PerfBug,SongOOPSLA2014}. 
In the previous work~\cite{PerfBug}, 
the authors collected 110 real-world performance bugs from 5 representative 
software suites, which are Apache, Chrome, GCC, Mozilla, and MySQL. 
These software suites cover various types of functionalities and are implemented 
by different programming languages, including C/C++, Java, C\#, and JavaScript. 
These software suites are all large and mature, 
with millions of lines of codes and long development histories. 
In their following work~\cite{SongOOPSLA2014}, 
the authors further identified 65 user-perceived performance bugs, 
which are all observed and reported by users. 


Our study focuses on user-perceived performance bugs, 
since these bugs have large performance impact.
After carefully reading bug reports and buggy code fragments of these bugs,
we clearly identify \ComBugs performance problems 
caused by {\textit{unexpected algorithmic complexity}}.
These performance problems will be referred to as 
{\textit{complexity problems}} in the reminder of this paper.


{\bf{\textit{Caveats.}}}
The same as all previous empirical studies, 
our findings and conclusions need to be considered together with our methodology.
All studied complexity bugs come from representative software. 
However, there are other types of software not covered in our study, 
such as distributed systems and HPC software. 
All studied complexity problems are reported by users through bug tracking systems.  
We do believe that there are complexity problems noticed 
and fixed by developers in other ways. 
However, there are no conceivable methods to study them.
We believe that the studied complexity problems can serve as a representative sample
of complexity problems in the real world. 


\subsection{Root causes of complexity problems}

\input{section/tab_study}


In this section, we study root causes of complexity problems in different categories. 
Our study focuses on 1) what code constructs causing the complexity problems, 
and 2) why the complexity problems can generate user-perceived performance impact. 

{\underline{\textit $O(N)$: linear complexity.}} 
As shown in Table~\ref{tab:study}, 
8 out of 30 studied complexity problems are in linear complexity. 
All of these problems are caused by a buggy loop, 
whose iterations scale in term of input size $N$.

For 5 of them, their corresponding buggy loops contain serialized IO operations.
Although loop iteration numbers or input sizes are not large,
these bugs can still cause user-perceived performance problems.
The patches for these bugs are to aggregate IO operations 
or completely eliminate unnecessary IO operations.   
For example, Mozilla\#490742 is caused by bookmarking tabs by using separated database transactions. 
Even bookmarking 50 tabs can cause the timeout dialog to pop up.
To fix this bug, mozilla developers use one aggregated transaction to bookmark all tabs together.
As another example, Mozilla\#344059 is due to saving unchanged 
search engine preferences to SQLite, 
and it is fixed by only saving search engine preferences when they are changed.

For the left 3 bugs, their buggy loops will execute many iterations during buggy runs,
and they are fixed by adding shortcuts to completely remove the buggy loops.
Take MySQL\#33948 as an example, 
originally MySQL developers keep both used and free table entries in the same linked list,
and the buggy loop is to go through the list and look for a free entry.
During buggy runs, many table entries are used and the buggy loop 
needs a lot of iteration to find a free entry. 
To fix this bug, MySQL developers separate used entries and free entries and keep them in two different linked lists. 

